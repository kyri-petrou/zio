"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[62021],{15680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>m});var a=t(96540);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(t),u=o,m=d["".concat(s,".").concat(u)]||d[u]||g[u]||r;return t?a.createElement(m,i(i({ref:n},c),{},{components:t})):a.createElement(m,i({ref:n},c))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[d]="string"==typeof e?e:o,i[1]=l;for(var p=2;p<r;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},86137:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>g,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=t(58168),o=(t(96540),t(15680));const r={id:"protocol-stack",title:"ProtocolStack"},i=void 0,l={unversionedId:"zio-http/dsl/protocol-stack",id:"zio-http/dsl/protocol-stack",title:"ProtocolStack",description:"The ProtocolStack is a low-level data type typically utilized in other higher abstractions such as HandlerAspect and Middleware for building middlewares. If you intend to write middleware, it is advisable in most cases to utilize these higher abstractions, as they simplify the process of middleware creation.",source:"@site/docs/zio-http/dsl/protocol-stack.md",sourceDirName:"zio-http/dsl",slug:"/zio-http/dsl/protocol-stack",permalink:"/zio-http/dsl/protocol-stack",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/zio-http/dsl/protocol-stack.md",tags:[],version:"current",frontMatter:{id:"protocol-stack",title:"ProtocolStack"},sidebar:"ecosystem-sidebar",previous:{title:"Flash",permalink:"/zio-http/dsl/flash"},next:{title:"Middleware",permalink:"/zio-http/dsl/middleware"}},s={},p=[{value:"Creating a ProtocolStack",id:"creating-a-protocolstack",level:2},{value:"Stateful ProtocolStacks",id:"stateful-protocolstacks",level:2},{value:"Working with ZIO Environment",id:"working-with-zio-environment",level:2},{value:"Conditional ProtocolStacks",id:"conditional-protocolstacks",level:2}],c={toc:p},d="wrapper";function g(e){let{components:n,...t}=e;return(0,o.yg)(d,(0,a.A)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("admonition",{type:"note"},(0,o.yg)("p",{parentName:"admonition"},"The ",(0,o.yg)("inlineCode",{parentName:"p"},"ProtocolStack")," is a low-level data type typically utilized in other higher abstractions such as ",(0,o.yg)("inlineCode",{parentName:"p"},"HandlerAspect")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"Middleware")," for building middlewares. If you intend to write middleware, it is advisable in most cases to utilize these higher abstractions, as they simplify the process of middleware creation."),(0,o.yg)("p",{parentName:"admonition"},"The ",(0,o.yg)("inlineCode",{parentName:"p"},"ProtocolStack")," is a more advanced concept that provides fine-grained control over the types of inputs and outputs at each layer of the middleware stack, instead of common ",(0,o.yg)("inlineCode",{parentName:"p"},"Request")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"Response")," types. Learning about ",(0,o.yg)("inlineCode",{parentName:"p"},"ProtocolStack")," is recommended as it can be beneficial for understanding the inner workings of how middleware is constructed.")),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"ProtocolStack")," is a data type that represents a stack of one or more protocol layers. Each layer in the stack is a function that transforms the incoming and outgoing values of some handler."),(0,o.yg)("p",null,"We can think of a ",(0,o.yg)("inlineCode",{parentName:"p"},"ProtocolStack")," as a function (or a composition of functions) that takes a handler and returns a new handler. The new handler is the result of applying each layer in the stack to the handler:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"trait ProtocolStack[-R, -II, +IO, -OI, +OO] {\n  def apply[Env <: R, Err >: OO, IncomingOut >: IO, OutgoingIn <: OI](\n    handler: Handler[Env, Err, IncomingOut, OutgoingIn],\n  ): Handler[Env, Err, II, OO]\n}\n")),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"ProtocolStack")," data type has 5 type parameters, one for the ZIO environment, and four for the incoming and outgoing input and output types of the protocol stack:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"Incoming Input"),": This refers to data coming into the middleware from the client's HTTP request or the previous middleware in the chain. It could include information such as headers, cookies, query parameters, and the request body.")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"Incoming Output"),": This refers to the data leaving the middleware and heading towards the server or the next middleware in the chain. This could include modified request data or additional metadata added by the middleware."))),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Outgoing Input"),": This refers to data coming into the middleware from the handler or the previous middleware in the chain. It typically includes the HTTP response from the server, including headers, status codes, and the response body."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Outgoing Output"),": This refers to data leaving the middleware and heading back to the client. It could include modified response data, additional headers, or any other transformations applied by the middleware."),(0,o.yg)("p",null,"A ",(0,o.yg)("inlineCode",{parentName:"p"},"ProtocolStack")," can be created by combining multiple middleware functions using the ",(0,o.yg)("inlineCode",{parentName:"p"},"++")," operator. Using the ",(0,o.yg)("inlineCode",{parentName:"p"},"++")," operator, we can stack multiple middleware functions on top of each other to create a composite middleware that applies each middleware in the order they are stacked."),(0,o.yg)("h2",{id:"creating-a-protocolstack"},"Creating a ProtocolStack"),(0,o.yg)("p",null,"There are several ways to create a ",(0,o.yg)("inlineCode",{parentName:"p"},"ProtocolStack"),". One simple way is to start with an ",(0,o.yg)("inlineCode",{parentName:"p"},"identity")," stack, which is a protocol stack that does nothing and simply passes the inputs to the outputs unchanged. Then, we can modify it by mapping over the inputs and outputs to apply transformations:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.http._\n\ntype Request  = String\ntype Response = String\nval identity: ProtocolStack[Any, Request, Request, Response, Response] =\n  ProtocolStack.identity[Request, Response]\n")),(0,o.yg)("p",null,"Assume we have a handler that takes a request and reverses it to create a response:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"val uppercase: Handler[Any, Nothing, Request, Response] =\n  Handler.fromFunction[Request](_.toUpperCase)\n")),(0,o.yg)("p",null,"If we apply the ",(0,o.yg)("inlineCode",{parentName:"p"},"uppercase")," handler to the ",(0,o.yg)("inlineCode",{parentName:"p"},"identity")," stack, it will simply return the same handler without any modifications:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"val handler: Handler[Any, Response, Request, Response] = identity(uppercase)\n")),(0,o.yg)("p",null,"The behavior of the ",(0,o.yg)("inlineCode",{parentName:"p"},"handler")," remains the same. Let's test it:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'Unsafe.unsafe{ implicit unsafe =>\n  Runtime.default.unsafe.run(\n    handler("Hello World!")\n  )\n}\n// res0: Exit[Response, Response] = Success(value = "HELLO WORLD!")\n')),(0,o.yg)("p",null,"The output should be ",(0,o.yg)("inlineCode",{parentName:"p"},"HELLO WORLD!"),", which is the result of applying the ",(0,o.yg)("inlineCode",{parentName:"p"},"uppercase")," handler to the ",(0,o.yg)("inlineCode",{parentName:"p"},"identity")," stack."),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"ProtocolStack")," has two main methods for transforming the incoming and outgoing values: ",(0,o.yg)("inlineCode",{parentName:"p"},"mapIncoming")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"mapOutgoing"),". Using these methods, we can apply transformations to the incoming and outgoing values of the protocol stack."),(0,o.yg)("p",null,"Let's create a new protocol stack that trims the incoming request, calculates the length of the outgoing response, and returns a tuple of the response and its length:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"val trimAndLength: ProtocolStack[Any, Request, Response, Response, (Response, Int)] =\n  identity.mapIncoming(_.trim).mapOutgoing(r => (r, r.length))\n")),(0,o.yg)("p",null,"Now, let's apply the ",(0,o.yg)("inlineCode",{parentName:"p"},"uppercase")," handler to the ",(0,o.yg)("inlineCode",{parentName:"p"},"trimAndLength")," stack:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'val newHandler: Handler[Any, (Response, Int), Request, (Response, Int)] =\n  trimAndLength(uppercase)\n\nUnsafe.unsafe { implicit unsafe =>\n  Runtime.default.unsafe.run(\n    newHandler("Hello World! "),\n  )\n}\n')),(0,o.yg)("p",null,"The output should be ",(0,o.yg)("inlineCode",{parentName:"p"},"(HELLO WORLD!, 12)"),", which is the result of applying the ",(0,o.yg)("inlineCode",{parentName:"p"},"uppercase")," handler to the ",(0,o.yg)("inlineCode",{parentName:"p"},"trimAndLength")," stack."),(0,o.yg)("p",null,"Please note that the ",(0,o.yg)("inlineCode",{parentName:"p"},"ProtocolStack")," also has ",(0,o.yg)("inlineCode",{parentName:"p"},"interceptIncomingHandler")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"interceptOutgoingHandler")," constructors that allow us to create a ",(0,o.yg)("inlineCode",{parentName:"p"},"ProtocolStack")," by intercepting the incoming and outgoing handlers and applying transformations to them:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"val trim: ProtocolStack[Any, Request, Request, Response, Response] =\n  ProtocolStack.interceptIncomingHandler(Handler.fromFunction[String](_.trim))\n\nval length: ProtocolStack[Any, Request, Request, Response, (Response, Int)] = \n  ProtocolStack.interceptOutgoingHandler(Handler.fromFunction[String](r => (r, r.length)))\n")),(0,o.yg)("p",null,"Then we can combine them using the ",(0,o.yg)("inlineCode",{parentName:"p"},"++")," operator:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"val anotherTrimAndLength: ProtocolStack[Any, Request, Request, Response, (Response, Int)] =\n  length ++ trim\n// anotherTrimAndLength: ProtocolStack[Any, Request, Request, Response, (Response, Int)] = Concat(\n//   left = Outgoing(handler = zio.http.Handler$FromFunction$$anon$16@1c6640f7),\n//   right = Incoming(handler = zio.http.Handler$FromFunction$$anon$16@66473eda)\n// )\n")),(0,o.yg)("p",null,"Now, let's apply the ",(0,o.yg)("inlineCode",{parentName:"p"},"uppercase")," handler to the ",(0,o.yg)("inlineCode",{parentName:"p"},"anotherTrimAndLength")," stack:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'Unsafe.unsafe { implicit unsafe =>\n  Runtime.default.unsafe.run(\n    anotherTrimAndLength(uppercase).apply("Hello World!"),\n  )\n}\n// res2: Exit[(Response, Int), (Response, Int)] = Success(\n//   value = ("HELLO WORLD!", 12)\n// )\n')),(0,o.yg)("p",null,"We should get the same output as before: ",(0,o.yg)("inlineCode",{parentName:"p"},"(HELLO WORLD!, 12)"),"."),(0,o.yg)("p",null,"When we want to apply a transformation to both the incoming and outgoing values, there is a very simple way to do it using the ",(0,o.yg)("inlineCode",{parentName:"p"},"interceptHandler")," constructor. It takes two handlers, one for transforming the incoming input and one for transforming the outgoing input:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"val an: ProtocolStack[Any, Response, Response, Response, (Response, RuntimeFlags)] =\n  ProtocolStack.interceptHandler(Handler.fromFunction[String](_.trim))(\n    Handler.fromFunction[String](r => (r, r.length)),\n  )\n")),(0,o.yg)("h2",{id:"stateful-protocolstacks"},"Stateful ProtocolStacks"),(0,o.yg)("p",null,"In some cases, we may need to maintain some state along with the protocol stack. We can achieve such stateful behavior by using the ",(0,o.yg)("inlineCode",{parentName:"p"},"interceptHandlerStateful")," constructor:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"object ProtocolStack {\n  def interceptHandlerStateful[Env, State, II, IO, OI, OO](\n    incomingInputHandler: Handler[Env, OO, II, (State, IO)],\n  )(\n    outgoingOutputHandler: Handler[Env, Nothing, (State, OI), OO],\n  ): ProtocolStack[Env, II, IO, OI, OO] = ???\n}\n")),(0,o.yg)("p",null,"The ",(0,o.yg)("inlineCode",{parentName:"p"},"interceptHandlerStateful")," constructor takes two handlers:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Incoming Input Handler"),"\u2014 Takes the incoming input of type ",(0,o.yg)("inlineCode",{parentName:"li"},"II")," and returns the state along with the incoming output of type ",(0,o.yg)("inlineCode",{parentName:"li"},"(State, IO)"),"."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Outgoing Input Handler"),"\u2014 Takes the state and the outgoing input of type ",(0,o.yg)("inlineCode",{parentName:"li"},"(State, OI)"),", and returns the outgoing output of type ",(0,o.yg)("inlineCode",{parentName:"li"},"OO"),".")),(0,o.yg)("p",null,"For example, assume we want to design a middleware to measure the total response time of the server. To achieve this, we should store the start time when the request enters the incoming input handler, and then access this state in the outgoing input handler to calculate the response time."),(0,o.yg)("p",null,"Let's create a protocol stack that measures the response time of the server:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"import java.util.concurrent.TimeUnit\n\nval incomingInputHandler: Handler[Any, Nothing, String, (Long, String)] =\n  Handler.fromFunctionZIO((in: String) => ZIO.clockWith(_.currentTime(TimeUnit.MILLISECONDS)).map(t => (t, in)))\n\nval outgoingInputHandler: Handler[Any, Nothing, (Long, String), (String, Long)] =\n  Handler.fromFunctionZIO { case (startedTime: Long, in: String) =>\n    ZIO.clockWith(_.currentTime(TimeUnit.MILLISECONDS).map(t => (in, t - startedTime)))\n  }\n\nval responseTime: ProtocolStack[Any, String, String, String, (String, Long)] =\n  ProtocolStack.interceptHandlerStateful(incomingInputHandler)(outgoingInputHandler)\n")),(0,o.yg)("p",null,"Finally, let's have a handler that converts the input to uppercase and takes some random time to process the request:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"val handler: Handler[Any, Nothing, String, String] = Handler.identity.mapZIO { (o: String) =>\n  ZIO.randomWith(_.nextLongBetween(0, 3000).flatMap(x => ZIO.sleep(Duration.fromMillis(x)))) *> ZIO.succeed(\n    o.toUpperCase,\n  )\n}\n")),(0,o.yg)("p",null,"Now, we are ready to test the ",(0,o.yg)("inlineCode",{parentName:"p"},"responseTime")," protocol stack by applying the ",(0,o.yg)("inlineCode",{parentName:"p"},"handler")," to it:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},'Unsafe.unsafe { implicit unsafe =>\n  Runtime.default.unsafe.run(\n    responseTime(handler).apply("Hello, World!").debug("Response along with its latency"),\n  )\n}\n// res3: Exit[(String, Long), (String, Long)] = Success(\n//   value = ("HELLO, WORLD!", 2005L)\n// )\n')),(0,o.yg)("p",null,"In the output, we should see the response which is the input converted to uppercase, and the response time in milliseconds."),(0,o.yg)("h2",{id:"working-with-zio-environment"},"Working with ZIO Environment"),(0,o.yg)("p",null,"The first type parameter of the ",(0,o.yg)("inlineCode",{parentName:"p"},"ProtocolStack")," data type represents the ZIO environment. This allows us to obtain access to the services and resources available in the environment when defining the protocol stack, like logging, configuration, database access, etc."),(0,o.yg)("p",null,"In the following example, we will create a protocol stack that keeps track of the number of requests received by the server by storing the global state (",(0,o.yg)("inlineCode",{parentName:"p"},"Ref[Int]"),") in the environment:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala",metastring:'title="zio-http-example/src/main/scala/example/middleware/CounterProtocolStackExample.scala" showLineNumbers"',title:'"zio-http-example/src/main/scala/example/middleware/CounterProtocolStackExample.scala"','showLineNumbers"':!0},'package example.middleware\n\nimport zio._\n\nimport zio.http._\n\nobject CounterProtocolStackExample extends ZIOAppDefault {\n  val uppercaseHandler: Handler[Any, Nothing, String, String] =\n    Handler.fromFunction[String](_.toUpperCase)\n\n  def requestCounter[I, O]: ProtocolStack[Ref[Long], I, I, O, (Long, O)] =\n    ProtocolStack.interceptHandlerStateful {\n      Handler.fromFunctionZIO[I] { (incomingInput: I) =>\n        for {\n          db <- ZIO.service[Ref[Long]]\n          _  <- db.update(_ + 1)\n          c  <- db.get\n        } yield (c, incomingInput)\n      }\n    }(Handler.identity)\n\n  val handler: Handler[Ref[Long], (Long, String), String, (Long, String)] =\n    requestCounter[String, String](uppercaseHandler)\n\n  def app = for {\n    _ <- handler("Hello!").debug\n    _ <- handler("Hello, World!").debug\n    _ <- handler("What is ZIO?").debug\n  } yield ()\n\n  def run = app.provide(ZLayer.fromZIO(Ref.make(0L)))\n}\n')),(0,o.yg)("h2",{id:"conditional-protocolstacks"},"Conditional ProtocolStacks"),(0,o.yg)("p",null,"In some cases, we may want to apply a protocol stack conditionally based on some criteria. We can achieve this by using the ",(0,o.yg)("inlineCode",{parentName:"p"},"cond")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"condZIO")," constructors inside the ",(0,o.yg)("inlineCode",{parentName:"p"},"ProtocolStack")," companion object."),(0,o.yg)("p",null,"They take a predicate function that determines which protocol stack to apply based on the incoming input:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-scala"},"import zio._\nimport zio.http._\n\ndef requestCounter[I, O]: ProtocolStack[Ref[Long], I, I, O, O] =\n  ProtocolStack.interceptIncomingHandler {\n    Handler.fromFunctionZIO[I] { (incomingInput: I) =>\n      ZIO.serviceWithZIO[Ref[Long]](_.update(_ + 1)).as(incomingInput)\n    }\n  }\n\ndef getMethodRequestCounter: ProtocolStack[Ref[Long], Request, Request, Response, Response] =\n  ProtocolStack\n    .cond[Request](_.method.matches(Method.GET))(\n      ifTrue = requestCounter[Request, Response],\n      ifFalse = ProtocolStack.identity[Request, Response],\n    )\n")),(0,o.yg)("p",null,"In the above example, we defined a protocol stack that only counts the number of requests for the ",(0,o.yg)("inlineCode",{parentName:"p"},"GET")," method. The state will be stored in a ",(0,o.yg)("inlineCode",{parentName:"p"},"Ref[Long]")," service in the ZIO environment."))}g.isMDXComponent=!0}}]);